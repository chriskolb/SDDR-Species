"Triatoma brasiliensis", "Triatoma sordida", "Triatoma pseudomaculata",
"Triatoma barberi")
mars.tot <- NULL
# loop over degrees of interaction
for(doi in 1:3){
mars.aucs <- NULL
mars.briers <- NULL
# loop over insample species
for(spec in insample.species){
## prepare species-specific data sets
# load list of prepared objects
#full.list <- readRDS(file = file.path(data.path, "full-model-list.rds"))
# load species-specific train and test sets
train <- eval(parse(text = paste0("full.list$train.dfs.var.spec$train.full.var.", gsub(" ", "", spec, fixed = TRUE))))
# original test sets from single species df
test <- full.list$basic.dfs$test.full
test <- test[test$spec == spec,]
# wrap df in list for pre-processing script
data <- list(train = train, test = test)
# set minimum number of unique observations per covariate
min.unique <- 45
# run data pre-processing script
source(file = file.path(data.path, "data-preprocessing-species.R"))
# estimate multi-response MARS
multi.mars <- suppressWarnings(earth(x = x.train.s, y = y.train, degree = doi, glm=list(family=binomial)) )
# predict test set
pred <- predict(object = multi.mars, newdata = x.test.s, type = "response")
colnames(pred) <- insample.species
# compute AUC and Brier score on test data of species
auc.spec <- AUC(y_pred = pred[,spec], y_true = y.test[,spec])
brier.spec <- BrierScore(resp = y.test[,spec], pred = pred[,spec])
cat("AUC for this species is = ", auc.spec, "\n")
cat("Brier Score for this species is = ", brier.spec, "\n")
mars.aucs <- cbind(mars.aucs, auc.spec)
mars.briers <- cbind(mars.briers, brier.spec)
# end loop over species
}
# summarise results for specific doi
colnames(mars.aucs) <- insample.species
mars.aucs <- data.frame(mars.aucs)
colnames(mars.briers) <- insample.species
mars.briers <- data.frame(mars.briers)
mars.res.doi <- rbind(mars.aucs, mars.briers)
rownames(mars.res.doi) <- c(paste0("AUC", doi), paste0("Brier", doi))
mars.res.doi$doi <- doi
mars.res.doi
mars.tot <- rbind(mars.tot, mars.res.doi)
mars.tot
# end loop over degrees of interaction
}
saveRDS(mars.tot, file = file.path(temp.data, paste0("results-MMARS-doi-",  timestamp, ".rds")))
mars.toot
mars.tot
mars.tot <- mars.tot[c(1,3,5,2,4,6),]
mars.tot
len(doirange)
doirange = 1:4
len(doirange)
#################################################################################################
## set up workspace
#################################################################################################
rm(list=ls())
library(devtools)
# load required packages
## install.packages("pacman")
pacman::p_load(Matrix, dplyr, keras, mgcv, reticulate, tensorflow, tfprobability,
Metrics, DescTools, MLmetrics, caret, xgboost, recipes, yardstick,
ParBayesianOptimization, doParallel, muStat, scoring, Hmisc, blockCV, earth, UBL)
# force conda environment
use_condaenv("r-reticulate", required = T)
# load deepregression package
load_all("H:/repo/deepregression-master-server")
# pre-processed array directory
data.path  <- "H:/species/multi-response/"
temp.data  <- "H:/species/multi-response/temp/"
# seed
seed = 42
tf$random$set_seed(seed = seed)
set.seed(seed)
# define timestamp to identify saved files
timestamp <- format(Sys.time(), "%Y-%m-%d-%H%M")
# set range for degree of interaction
doirange <- 1:4
# set subsampling type (none, lpros, lprus, adasyn)
subsampling <- "none"
#subsampling <- "lpros"
#subsampling <- "lprus"
#subsampling <- "adasyn"
# load list of prepared objects
full.list <- readRDS(file = file.path(data.path, "full-model-list.rds"))
#for(imbalance.method in c("none", "lprus", "lpros", "adasyn")){
#  subsampling <- imbalance.method
################################################################################################
################## train and evaluate MMARS on species-specific data sets ######################
################################################################################################
insample.species <- c("Triatoma infestans", "Triatoma dimidiata", "Panstrongylus megistus",
"Triatoma brasiliensis", "Triatoma sordida", "Triatoma pseudomaculata",
"Triatoma barberi")
mars.tot <- NULL
# loop over degrees of interaction
for(doi in doirange){
mars.aucs <- NULL
mars.briers <- NULL
# loop over insample species
for(spec in insample.species){
## prepare species-specific data sets
# load list of prepared objects
#full.list <- readRDS(file = file.path(data.path, "full-model-list.rds"))
# load species-specific train and test sets
train <- eval(parse(text = paste0("full.list$train.dfs.var.spec$train.full.var.", gsub(" ", "", spec, fixed = TRUE))))
# original test sets from single species df
test <- full.list$basic.dfs$test.full
test <- test[test$spec == spec,]
# wrap df in list for pre-processing script
data <- list(train = train, test = test)
# set minimum number of unique observations per covariate
min.unique <- 45
# run data pre-processing script
source(file = file.path(data.path, "data-preprocessing-species.R"))
# estimate multi-response MARS
multi.mars <- suppressWarnings(earth(x = x.train.s, y = y.train, degree = doi, glm=list(family=binomial)) )
# predict test set
pred <- predict(object = multi.mars, newdata = x.test.s, type = "response")
colnames(pred) <- insample.species
# compute AUC and Brier score on test data of species
auc.spec <- AUC(y_pred = pred[,spec], y_true = y.test[,spec])
brier.spec <- BrierScore(resp = y.test[,spec], pred = pred[,spec])
cat("AUC for this species is = ", auc.spec, "\n")
cat("Brier Score for this species is = ", brier.spec, "\n")
mars.aucs <- cbind(mars.aucs, auc.spec)
mars.briers <- cbind(mars.briers, brier.spec)
# end loop over species
}
# summarise results for specific doi
colnames(mars.aucs) <- insample.species
mars.aucs <- data.frame(mars.aucs)
colnames(mars.briers) <- insample.species
mars.briers <- data.frame(mars.briers)
mars.res.doi <- rbind(mars.aucs, mars.briers)
rownames(mars.res.doi) <- c(paste0("AUC", doi), paste0("Brier", doi))
mars.res.doi$doi <- doi
mars.res.doi
mars.tot <- rbind(mars.tot, mars.res.doi)
# end loop over degrees of interaction
}
if(len(doirange) == 4){mars.tot <- mars.tot[c(1,3,5,7,2,4,6,8),]} else{mars.tot <- mars.tot[c(1,3,5,2,4,6),]}
mars.tot
saveRDS(mars.tot, file = file.path(temp.data, paste0("results-MMARS-doi-",  timestamp, ".rds")))
#################################################################################################
## set up workspace
#################################################################################################
rm(list=ls())
library(devtools)
# load required packages
## install.packages("pacman")
pacman::p_load(Matrix, dplyr, keras, mgcv, reticulate, tensorflow, tfprobability,
Metrics, DescTools, MLmetrics, caret, xgboost, recipes, yardstick,
ParBayesianOptimization, doParallel, muStat, scoring, Hmisc, blockCV, earth, UBL)
# force conda environment
use_condaenv("r-reticulate", required = T)
# load deepregression package
load_all("H:/repo/deepregression-master-server")
# pre-processed array directory
data.path  <- "H:/species/multi-response/"
temp.data  <- "H:/species/multi-response/temp/"
# seed
seed = 42
tf$random$set_seed(seed = seed)
set.seed(seed)
# define timestamp to identify saved files
timestamp <- format(Sys.time(), "%Y-%m-%d-%H%M")
# set range for degree of interaction
doirange <- 1:4
# set subsampling type (none, lpros, lprus, adasyn)
subsampling <- "none"
#subsampling <- "lpros"
#subsampling <- "lprus"
#subsampling <- "adasyn"
# load list of prepared objects
full.list <- readRDS(file = file.path(data.path, "full-model-list.rds"))
#for(imbalance.method in c("none", "lprus", "lpros", "adasyn")){
#  subsampling <- imbalance.method
################################################################################################
################## train and evaluate MMARS on species-specific data sets ######################
################################################################################################
insample.species <- c("Triatoma infestans", "Triatoma dimidiata", "Panstrongylus megistus",
"Triatoma brasiliensis", "Triatoma sordida", "Triatoma pseudomaculata",
"Triatoma barberi")
mars.tot <- NULL
# loop over degrees of interaction
for(doi in doirange){
mars.aucs <- NULL
mars.briers <- NULL
# loop over insample species
for(spec in insample.species){
## prepare species-specific data sets
# load list of prepared objects
#full.list <- readRDS(file = file.path(data.path, "full-model-list.rds"))
# load species-specific train and test sets
train <- eval(parse(text = paste0("full.list$train.dfs.var.spec$train.full.var.", gsub(" ", "", spec, fixed = TRUE))))
# original test sets from single species df
test <- full.list$basic.dfs$test.full
test <- test[test$spec == spec,]
# wrap df in list for pre-processing script
data <- list(train = train, test = test)
# set minimum number of unique observations per covariate
min.unique <- 45
# run data pre-processing script
source(file = file.path(data.path, "data-preprocessing-species.R"))
# estimate multi-response MARS
multi.mars <- suppressWarnings(earth(x = x.train.s, y = y.train, degree = doi, glm=list(family=binomial)) )
# predict test set
pred <- predict(object = multi.mars, newdata = x.test.s, type = "response")
colnames(pred) <- insample.species
# compute AUC and Brier score on test data of species
auc.spec <- AUC(y_pred = pred[,spec], y_true = y.test[,spec])
brier.spec <- BrierScore(resp = y.test[,spec], pred = pred[,spec])
cat("AUC for this species is = ", auc.spec, "\n")
cat("Brier Score for this species is = ", brier.spec, "\n")
mars.aucs <- cbind(mars.aucs, auc.spec)
mars.briers <- cbind(mars.briers, brier.spec)
# end loop over species
}
# summarise results for specific doi
colnames(mars.aucs) <- insample.species
mars.aucs <- data.frame(mars.aucs)
colnames(mars.briers) <- insample.species
mars.briers <- data.frame(mars.briers)
mars.res.doi <- rbind(mars.aucs, mars.briers)
rownames(mars.res.doi) <- c(paste0("AUC", doi), paste0("Brier", doi))
mars.res.doi$doi <- doi
mars.res.doi
mars.tot <- rbind(mars.tot, mars.res.doi)
# end loop over degrees of interaction
}
if(len(doirange) == 4){mars.tot <- mars.tot[c(1,3,5,7,2,4,6,8),]} else{mars.tot <- mars.tot[c(1,3,5,2,4,6),]}
mars.tot
saveRDS(mars.tot, file = file.path(temp.data, "multi-mars", paste0("results-MMARS-doi-",  timestamp, ".rds")))
View(mars.tot)
################################################################################################
# Bayesian Hyperparameter Optimization for Full model including all species
################################################################################################
rm(list=ls())
# script parameters:
# choose SDDR predictor
#preds.list <- c("deep", "smooth", "smooth-deep")
pred.type = "deep" # smooth, deep, smooth-deep
# fixed number of epochs for optimization
epochs.cv = 100
# bayesian optimization steps
init.pts = 100
optim.steps = 100
# number of simulations for mean result of optimized model
numsims = 10
# set subsampling type (none, lpros, lprus, adasyn)
subsampling <- "none"
# set Bayesian Optimization criterion (auc, loss)
optim.crit <- "auc"
#################################################################################################
## set up workspace
#################################################################################################
library(devtools)
# load required packages
## install.packages("pacman")
pacman::p_load(Matrix, dplyr, keras, mgcv, reticulate, tensorflow, tfprobability,
Metrics, DescTools, MLmetrics, caret, xgboost, recipes, yardstick,
ParBayesianOptimization, doParallel, muStat, scoring, Hmisc, blockCV,
UBL)
# force conda environment
use_condaenv("r-reticulate", required = T)
# load deepregression package
load_all("H:/repo/deepregression-master-server")
# pre-processed array directory
data.path  <- "H:/species/multi-response/"
temp.data  <- "H:/species/multi-response/temp/"
# seed
seed = 42
tf$random$set_seed(seed = seed)
set.seed(seed)
# timestap to name all output files
timestamp <- format(Sys.time(), "%Y-%m-%d-%H%M")
################################################################################################
## load and prepare data #######################################################################
################################################################################################
# load list of prepared objects
full.list <- readRDS(file = file.path(data.path, "full-model-list.rds"))
# load df.tune as training data for bayesian hyperparameter optimization
train <- full.list$basic.dfs$df.tune.var
# original test sets from single species df
test <- full.list$basic.dfs$test.full
# wrap df in list for pre-processing script
data <- list(train = train, test = test)
# set minimum number of unique observations per covariate
min.unique <- 45
# run data pre-processing script
source(file = file.path(data.path, "data-preprocessing.R"))
# define predictor formulae:  smooth, smooth-deep, deep
source(file = file.path(data.path, "formulae.R"))
# model formula
if (pred.type == "smooth"){
form.mod <- form.smooth
} else if (pred.type == "smooth-deep"){
form.mod <- form.smooth.deep
} else{
form.mod <- form.deep
}
form.mod
# set hyperparameters that are not included in bayesian GP optimization
batch.size.nn = 20
lambda.l1 = 0
batchnorm = 1 # 1 = yes, 2 = no
# initialize arguments for testing purposes
hidden.units.num = 3 # 1=32, 2=64, 3=128, 4=256
hidden.layers = 2
dropout.nn = 0.2
log.lr.nn = -3
log.decay.nn = -4
act.num = 1 # 1=relu, 2=tanh
init.num = 2 # 1=glorot_normal, 2=he_normal
if(pred.type == "deep"){df.smooth = NULL} else{df.smooth = 9}
ScoreResult <- readRDS("H:/species/multi-response/temp/batch-5-10-20/bhopt-multi-softmax-auc-none-deep-spatcv-2020-10-01-0238.rds")
# get best parameters for highest CV AUC
best.pars.bopt <- getBestPars(ScoreResult)
#best.pars.bopt <- getBestPars(ScoreResultAdd)
best.pars.bopt
# re-transform log rates from hyperparam search
lr.nn <- exp(best.pars.bopt$log.lr.nn)
decay.nn <- exp(best.pars.bopt$log.decay.nn)
# set batchnorm to 1 (yes) per default
batchnorm = 1 # 1 = yes, 2 = no
# hidden units in first hidden layer
hidden.units.list <- c(32, 64, 128, 256)
hidden.units1 <- hidden.units.list[best.pars.bopt$hidden.units.num]
# activation function
activations <- list("relu", "tanh")
act.nn  <- activations[[1]]  # act.num
# initializers
initializers   <- list(
"initializer_glorot_normal()",
"initializer_he_normal()"
)
init.nn <- initializers[[2]]
## define NN architecture as function of hyperparameters
# start.block + building.block.1 + ... + building.block.i + end.block
# start block
start.block <- paste0(
"function(x) x %>%
layer_dense(units = ", hidden.units1, ", activation = '", act.nn, "',
kernel_initializer = ", init.nn, "
) %>% \n",
ifelse(batchnorm==1, "    layer_batch_normalization() %>% \n", ""),
"    layer_dropout(rate = ", best.pars.bopt$dropout.nn, ", seed = seed) %>% \n"
)
# middle blocks (hidden layers 2-x)
building.block <- paste0(
"    layer_dense(units = ", 0.5*hidden.units1, ", activation = '", act.nn, "',
kernel_initializer = ", init.nn, "
) %>% \n",
ifelse(batchnorm==1, "    layer_batch_normalization() %>% \n", ""),
"    layer_dropout(rate = ", best.pars.bopt$dropout.nn, ", seed = seed) %>% \n"
)
nn.body <- paste0(strrep(times = (best.pars.bopt$hidden.layers-1), building.block))
nn.body
# output layer
end.block <- paste0(
"    layer_dense(units = 8, activation = 'linear',
kernel_initializer = ", init.nn, "
)"
)
nn_deep = eval(parse(text = paste0(
start.block,
nn.body,
end.block
)))
nn_deep
best.pars.bopt
################################################################################################
##################### train and evaluate on species-specific data sets #########################
################################################################################################
insample.species <- c("Triatoma infestans", "Triatoma dimidiata", "Panstrongylus megistus",
"Triatoma brasiliensis", "Triatoma sordida", "Triatoma pseudomaculata",
"Triatoma barberi")
#insample.species <- c("Triatoma infestans", "Triatoma dimidiata")
# create data frame for results (numsims x species)
simu.runs.spec <- as.data.frame(1:numsims)
names(simu.runs.spec) <- "run"
# create data frame for results (numsims x species)
brier.runs.spec <- as.data.frame(1:numsims)
names(brier.runs.spec) <- "run"
# loop over insample species
for(spec in insample.species){
## prepare species-specific data sets
# load list of prepared objects
#full.list <- readRDS(file = file.path(data.path, "full-model-list.rds"))
# load species-specific train and test sets
train <- eval(parse(text = paste0("full.list$train.dfs.var.spec$train.full.var.", gsub(" ", "", spec, fixed = TRUE))))
# original test sets from single species df
test <- full.list$basic.dfs$test.full
test <- test[test$spec == spec,]
# wrap df in list for pre-processing script
data <- list(train = train, test = test)
# set minimum number of unique observations per covariate
min.unique <- 45
# run data pre-processing script
source(file = file.path(data.path, "data-preprocessing-species.R"))
# recalibrate formulae to new data frame (other covariates)
source(file = file.path(data.path, "formulae.R"))
# model formula
if (pred.type == "smooth"){
form.mod <- form.smooth
} else if (pred.type == "smooth-deep"){
form.mod <- form.smooth.deep
} else{
form.mod <- form.deep
}
form.mod
# train model on species-specific full data set for numsims simulations
simu.runs <- NULL
simu.runs <- as.data.frame( rep(0, numsims) )
names(simu.runs) <- spec
brier.runs <- NULL
brier.runs <- as.data.frame(rep(0, numsims))
names(brier.runs) <- spec
for(simu in 1:numsims){
# define deepregression object
mod.post.bopt <-  deepregression(y = y.train.onehot,
list_of_formulae = list(logit = form.mod),
list_of_deep_models = list(nn_deep = nn_deep),
data = x.train.s,
family = "multinoulli",
#dist_fun = function(x) tfd_bernoulli(x),
lambda_lasso = lambda.l1,
df = best.pars.bopt$df.smooth,
orthog_type = "manual",
zero_constraint_for_smooths = TRUE,
absorb_cons = FALSE,
optimizer = optimizer_adam(
decay = decay.nn,
lr = lr.nn
)
#,validation_data = list(x.test.s, y.test)
#,cv_folds = spat.cv.indices,
#,monitor_metric = c("accuracy")
)
# fit model with optimal number of epochs
hist.post.bopt <- mod.post.bopt %>% fit(
epochs = epochs.cv
,view_metrics = TRUE
,verbose = TRUE
,batch_size = batch.size.nn
#,auc_callback = TRUE
#,val_data = list(x.test.s, y.test)
,validation_split = 0
)
# predict on test set
pred <- mod.post.bopt %>% predict(x.test.s)
colnames(pred) <- c(insample.species, "none")
hist(pred)
summary(pred)
pred.spec <- pred[,spec]
# evaluate prediction with AUC
auc.test <- MLmetrics::AUC(y_pred = pred.spec, y_true = y.test.onehot[,spec])
#auc.test <- Metrics::auc(actual = y.test[,spec], predicted = pred.spec)
cat("\nTest AUC for species", spec, "in simulation number", simu, " is ", auc.test, "\n")
# evaluate prediction with Brier score
brier.test <- BrierScore(resp = y.test.onehot[,spec], pred = pred.spec)
cat("\nTest Brier score for species", spec, "in simulation number", simu, " is ", brier.test, "\n\n")
simu.runs[simu,1] <- auc.test
brier.runs[simu,1] <- brier.test
# end loop over simulation runs
}
simu.runs
mean.res <- round(mean(simu.runs[,1]), digits =3)
mean.res
sd.res   <- signif(stdev(simu.runs[,1], unbiased = T), digits=1)
sd.res
brier.runs
brier.mean <- round(mean(brier.runs[,1]), digits=3)
brier.mean
brier.sd <- signif(stdev(brier.runs[,1], unbiased = T), digits=1)
brier.sd
cat(" Final multi-class model for species", spec, "and predictor", pred.type, "\n",  "yields mean test AUC of = ", mean.res,
" with sd = ", sd.res, "\n")
cat(" Final multi-class model for species", spec, "and predictor", pred.type, "\n",  "yields mean test Brier Score of = ", brier.mean,
" with sd = ", brier.sd, "\n")
simu.runs.spec <- cbind(simu.runs.spec, simu.runs)
brier.runs.spec <- cbind(brier.runs.spec, brier.runs)
# end loop over species
}
# aggregate test AUC results for all species
simu.summary <- simu.runs.spec  %>% summarize_all(list(m=mean, sd=stats::sd))
simu.means <- round(simu.summary[1:(len(insample.species)+1)], digits=3)
names(simu.means) <- names(simu.runs.spec)
simu.sds <- signif(simu.summary[(len(insample.species)+2):(2*len(insample.species)+2)], digits=1)
names(simu.sds) <- names(simu.runs.spec)
simu.runs.all <- rbind(simu.runs.spec, simu.means, simu.sds)
rownames(simu.runs.all)[(numsims+1):(numsims+2)] <- c("means", "stdevs")
View(simu.runs.all)
# aggregate test Brier score for all species
brier.summary <- brier.runs.spec %>% summarize_all(list(m=mean, sd = stats::sd))
brier.means <- round(brier.summary[1:(len(insample.species)+1)], digits=3)
names(brier.means) <- names(brier.runs.spec)
brier.sds <- signif(brier.summary[(len(insample.species)+2):(2*len(insample.species)+2)], digits=1)
names(brier.sds) <- names(brier.runs.spec)
brier.runs.all <- rbind(brier.runs.spec, brier.means, brier.sds)
rownames(brier.runs.all)[(numsims+1):(numsims+2)] <- c("means", "stdevs")
View(brier.runs.all)
# save results
saveRDS(simu.runs.all, file = file.path(temp.data, paste0("simu-runs-MC-", optim.crit, "-", subsampling, "-", pred.type,
"-",  timestamp, ".rds")))
saveRDS(brier.runs.all, file = file.path(temp.data, paste0("brier-simus-MC-", optim.crit, "-", subsampling, "-", pred.type,
"-",  timestamp, ".rds")))
